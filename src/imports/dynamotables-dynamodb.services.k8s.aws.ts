// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Table is the Schema for the Tables API
 *
 * @schema Table
 */
export class Table extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Table"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.services.k8s.aws/v1alpha1',
    kind: 'Table',
  };

  /**
   * Renders a Kubernetes manifest for "Table".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableProps = {}): any {
    return {
      ...Table.GVK,
      ...toJson_TableProps(props),
    };
  }

  /**
   * Defines a "Table" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableProps = {}) {
    super(scope, id, {
      ...Table.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Table.GVK,
      ...toJson_TableProps(resolved),
    };
  }
}

/**
 * Table is the Schema for the Tables API
 *
 * @schema Table
 */
export interface TableProps {
  /**
   * @schema Table#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableSpec defines the desired state of Table.
   *
   * @schema Table#spec
   */
  readonly spec?: TableSpec;

}

/**
 * Converts an object of type 'TableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableProps(obj: TableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableSpec defines the desired state of Table.
 *
 * @schema TableSpec
 */
export interface TableSpec {
  /**
   * An array of attributes that describe the key schema for the table and indexes.
   *
   * @schema TableSpec#attributeDefinitions
   */
  readonly attributeDefinitions: TableSpecAttributeDefinitions[];

  /**
   * Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.
   * * PROVISIONED - We recommend using PROVISIONED for predictable workloads.    PROVISIONED sets the billing mode to Provisioned Mode (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual).
   * * PAY_PER_REQUEST - We recommend using PAY_PER_REQUEST for unpredictable    workloads. PAY_PER_REQUEST sets the billing mode to On-Demand Mode (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand).
   *
   * @schema TableSpec#billingMode
   */
  readonly billingMode?: string;

  /**
   * One or more global secondary indexes (the maximum is 20) to be created on the table. Each global secondary index in the array includes the following:
   * * IndexName - The name of the global secondary index. Must be unique only    for this table.
   * * KeySchema - Specifies the key schema for the global secondary index.
   * * Projection - Specifies attributes that are copied (projected) from the    table into the index. These are in addition to the primary key attributes    and index key attributes, which are automatically projected. Each attribute    specification is composed of: ProjectionType - One of the following: KEYS_ONLY    - Only the index and primary keys are projected into the index. INCLUDE    - Only the specified table attributes are projected into the index. The    list of projected attributes is in NonKeyAttributes. ALL - All of the    table attributes are projected into the index. NonKeyAttributes - A list    of one or more non-key attribute names that are projected into the secondary    index. The total count of attributes provided in NonKeyAttributes, summed    across all of the secondary indexes, must not exceed 100. If you project    the same attribute into two different indexes, this counts as two distinct    attributes when determining the total.
   * * ProvisionedThroughput - The provisioned throughput settings for the    global secondary index, consisting of read and write capacity units.
   *
   * @schema TableSpec#globalSecondaryIndexes
   */
  readonly globalSecondaryIndexes?: TableSpecGlobalSecondaryIndexes[];

  /**
   * Specifies the attributes that make up the primary key for a table or an index. The attributes in KeySchema must also be defined in the AttributeDefinitions array. For more information, see Data Model (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html) in the Amazon DynamoDB Developer Guide.
   * Each KeySchemaElement in the array is composed of:
   * * AttributeName - The name of this key attribute.
   * * KeyType - The role that the key attribute will assume: HASH - partition    key RANGE - sort key
   * The partition key of an item is also known as its hash attribute. The term "hash attribute" derives from the DynamoDB usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
   * The sort key of an item is also known as its range attribute. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
   * For a simple primary key (partition key), you must provide exactly one element with a KeyType of HASH.
   * For a composite primary key (partition key and sort key), you must provide exactly two elements, in this order: The first element must have a KeyType of HASH, and the second element must have a KeyType of RANGE.
   * For more information, see Working with Tables (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key) in the Amazon DynamoDB Developer Guide.
   *
   * @schema TableSpec#keySchema
   */
  readonly keySchema: TableSpecKeySchema[];

  /**
   * One or more local secondary indexes (the maximum is 5) to be created on the table. Each index is scoped to a given partition key value. There is a 10 GB size limit per partition key value; otherwise, the size of a local secondary index is unconstrained.
   * Each local secondary index in the array includes the following:
   * * IndexName - The name of the local secondary index. Must be unique only    for this table.
   * * KeySchema - Specifies the key schema for the local secondary index.    The key schema must begin with the same partition key as the table.
   * * Projection - Specifies attributes that are copied (projected) from the    table into the index. These are in addition to the primary key attributes    and index key attributes, which are automatically projected. Each attribute    specification is composed of: ProjectionType - One of the following: KEYS_ONLY    - Only the index and primary keys are projected into the index. INCLUDE    - Only the specified table attributes are projected into the index. The    list of projected attributes is in NonKeyAttributes. ALL - All of the    table attributes are projected into the index. NonKeyAttributes - A list    of one or more non-key attribute names that are projected into the secondary    index. The total count of attributes provided in NonKeyAttributes, summed    across all of the secondary indexes, must not exceed 100. If you project    the same attribute into two different indexes, this counts as two distinct    attributes when determining the total.
   *
   * @schema TableSpec#localSecondaryIndexes
   */
  readonly localSecondaryIndexes?: TableSpecLocalSecondaryIndexes[];

  /**
   * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
   * If you set BillingMode as PROVISIONED, you must specify this property. If you set BillingMode as PAY_PER_REQUEST, you cannot specify this property.
   * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
   *
   * @schema TableSpec#provisionedThroughput
   */
  readonly provisionedThroughput?: TableSpecProvisionedThroughput;

  /**
   * Represents the settings used to enable server-side encryption.
   *
   * @schema TableSpec#sseSpecification
   */
  readonly sseSpecification?: TableSpecSseSpecification;

  /**
   * The settings for DynamoDB Streams on the table. These settings consist of:
   * * StreamEnabled - Indicates whether DynamoDB Streams is to be enabled    (true) or disabled (false).
   * * StreamViewType - When an item in the table is modified, StreamViewType    determines what information is written to the table's stream. Valid values    for StreamViewType are: KEYS_ONLY - Only the key attributes of the modified    item are written to the stream. NEW_IMAGE - The entire item, as it appears    after it was modified, is written to the stream. OLD_IMAGE - The entire    item, as it appeared before it was modified, is written to the stream.    NEW_AND_OLD_IMAGES - Both the new and the old item images of the item    are written to the stream.
   *
   * @schema TableSpec#streamSpecification
   */
  readonly streamSpecification?: TableSpecStreamSpecification;

  /**
   * The name of the table to create.
   *
   * @schema TableSpec#tableName
   */
  readonly tableName: string;

  /**
   * A list of key-value pairs to label the table. For more information, see Tagging for DynamoDB (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html).
   *
   * @schema TableSpec#tags
   */
  readonly tags?: TableSpecTags[];

}

/**
 * Converts an object of type 'TableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpec(obj: TableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeDefinitions': obj.attributeDefinitions?.map(y => toJson_TableSpecAttributeDefinitions(y)),
    'billingMode': obj.billingMode,
    'globalSecondaryIndexes': obj.globalSecondaryIndexes?.map(y => toJson_TableSpecGlobalSecondaryIndexes(y)),
    'keySchema': obj.keySchema?.map(y => toJson_TableSpecKeySchema(y)),
    'localSecondaryIndexes': obj.localSecondaryIndexes?.map(y => toJson_TableSpecLocalSecondaryIndexes(y)),
    'provisionedThroughput': toJson_TableSpecProvisionedThroughput(obj.provisionedThroughput),
    'sseSpecification': toJson_TableSpecSseSpecification(obj.sseSpecification),
    'streamSpecification': toJson_TableSpecStreamSpecification(obj.streamSpecification),
    'tableName': obj.tableName,
    'tags': obj.tags?.map(y => toJson_TableSpecTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents an attribute for describing the key schema for the table and indexes.
 *
 * @schema TableSpecAttributeDefinitions
 */
export interface TableSpecAttributeDefinitions {
  /**
   * @schema TableSpecAttributeDefinitions#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecAttributeDefinitions#attributeType
   */
  readonly attributeType?: string;

}

/**
 * Converts an object of type 'TableSpecAttributeDefinitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecAttributeDefinitions(obj: TableSpecAttributeDefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'attributeType': obj.attributeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the properties of a global secondary index.
 *
 * @schema TableSpecGlobalSecondaryIndexes
 */
export interface TableSpecGlobalSecondaryIndexes {
  /**
   * @schema TableSpecGlobalSecondaryIndexes#indexName
   */
  readonly indexName?: string;

  /**
   * @schema TableSpecGlobalSecondaryIndexes#keySchema
   */
  readonly keySchema?: TableSpecGlobalSecondaryIndexesKeySchema[];

  /**
   * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
   *
   * @schema TableSpecGlobalSecondaryIndexes#projection
   */
  readonly projection?: TableSpecGlobalSecondaryIndexesProjection;

  /**
   * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
   * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
   *
   * @schema TableSpecGlobalSecondaryIndexes#provisionedThroughput
   */
  readonly provisionedThroughput?: TableSpecGlobalSecondaryIndexesProvisionedThroughput;

}

/**
 * Converts an object of type 'TableSpecGlobalSecondaryIndexes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecGlobalSecondaryIndexes(obj: TableSpecGlobalSecondaryIndexes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'keySchema': obj.keySchema?.map(y => toJson_TableSpecGlobalSecondaryIndexesKeySchema(y)),
    'projection': toJson_TableSpecGlobalSecondaryIndexesProjection(obj.projection),
    'provisionedThroughput': toJson_TableSpecGlobalSecondaryIndexesProvisionedThroughput(obj.provisionedThroughput),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents a single element of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index.
 * A KeySchemaElement represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one KeySchemaElement (for the partition key). A composite primary key would require one KeySchemaElement for the partition key, and another KeySchemaElement for the sort key.
 * A KeySchemaElement must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.
 *
 * @schema TableSpecKeySchema
 */
export interface TableSpecKeySchema {
  /**
   * @schema TableSpecKeySchema#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecKeySchema#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'TableSpecKeySchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecKeySchema(obj: TableSpecKeySchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the properties of a local secondary index.
 *
 * @schema TableSpecLocalSecondaryIndexes
 */
export interface TableSpecLocalSecondaryIndexes {
  /**
   * @schema TableSpecLocalSecondaryIndexes#indexName
   */
  readonly indexName?: string;

  /**
   * @schema TableSpecLocalSecondaryIndexes#keySchema
   */
  readonly keySchema?: TableSpecLocalSecondaryIndexesKeySchema[];

  /**
   * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
   *
   * @schema TableSpecLocalSecondaryIndexes#projection
   */
  readonly projection?: TableSpecLocalSecondaryIndexesProjection;

}

/**
 * Converts an object of type 'TableSpecLocalSecondaryIndexes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecLocalSecondaryIndexes(obj: TableSpecLocalSecondaryIndexes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'keySchema': obj.keySchema?.map(y => toJson_TableSpecLocalSecondaryIndexesKeySchema(y)),
    'projection': toJson_TableSpecLocalSecondaryIndexesProjection(obj.projection),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
 * If you set BillingMode as PROVISIONED, you must specify this property. If you set BillingMode as PAY_PER_REQUEST, you cannot specify this property.
 * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
 *
 * @schema TableSpecProvisionedThroughput
 */
export interface TableSpecProvisionedThroughput {
  /**
   * @schema TableSpecProvisionedThroughput#readCapacityUnits
   */
  readonly readCapacityUnits?: number;

  /**
   * @schema TableSpecProvisionedThroughput#writeCapacityUnits
   */
  readonly writeCapacityUnits?: number;

}

/**
 * Converts an object of type 'TableSpecProvisionedThroughput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProvisionedThroughput(obj: TableSpecProvisionedThroughput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readCapacityUnits': obj.readCapacityUnits,
    'writeCapacityUnits': obj.writeCapacityUnits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the settings used to enable server-side encryption.
 *
 * @schema TableSpecSseSpecification
 */
export interface TableSpecSseSpecification {
  /**
   * @schema TableSpecSseSpecification#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema TableSpecSseSpecification#kmsMasterKeyID
   */
  readonly kmsMasterKeyId?: string;

  /**
   * @schema TableSpecSseSpecification#sseType
   */
  readonly sseType?: string;

}

/**
 * Converts an object of type 'TableSpecSseSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecSseSpecification(obj: TableSpecSseSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'kmsMasterKeyID': obj.kmsMasterKeyId,
    'sseType': obj.sseType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The settings for DynamoDB Streams on the table. These settings consist of:
 * * StreamEnabled - Indicates whether DynamoDB Streams is to be enabled    (true) or disabled (false).
 * * StreamViewType - When an item in the table is modified, StreamViewType    determines what information is written to the table's stream. Valid values    for StreamViewType are: KEYS_ONLY - Only the key attributes of the modified    item are written to the stream. NEW_IMAGE - The entire item, as it appears    after it was modified, is written to the stream. OLD_IMAGE - The entire    item, as it appeared before it was modified, is written to the stream.    NEW_AND_OLD_IMAGES - Both the new and the old item images of the item    are written to the stream.
 *
 * @schema TableSpecStreamSpecification
 */
export interface TableSpecStreamSpecification {
  /**
   * @schema TableSpecStreamSpecification#streamEnabled
   */
  readonly streamEnabled?: boolean;

  /**
   * @schema TableSpecStreamSpecification#streamViewType
   */
  readonly streamViewType?: string;

}

/**
 * Converts an object of type 'TableSpecStreamSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecStreamSpecification(obj: TableSpecStreamSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamEnabled': obj.streamEnabled,
    'streamViewType': obj.streamViewType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single DynamoDB table.
 * AWS-assigned tag names and values are automatically assigned the aws: prefix, which the user cannot assign. AWS-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix user: in the Cost Allocation Report. You cannot backdate the application of a tag.
 * For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html) in the Amazon DynamoDB Developer Guide.
 *
 * @schema TableSpecTags
 */
export interface TableSpecTags {
  /**
   * @schema TableSpecTags#key
   */
  readonly key?: string;

  /**
   * @schema TableSpecTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TableSpecTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecTags(obj: TableSpecTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents a single element of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index.
 * A KeySchemaElement represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one KeySchemaElement (for the partition key). A composite primary key would require one KeySchemaElement for the partition key, and another KeySchemaElement for the sort key.
 * A KeySchemaElement must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.
 *
 * @schema TableSpecGlobalSecondaryIndexesKeySchema
 */
export interface TableSpecGlobalSecondaryIndexesKeySchema {
  /**
   * @schema TableSpecGlobalSecondaryIndexesKeySchema#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecGlobalSecondaryIndexesKeySchema#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'TableSpecGlobalSecondaryIndexesKeySchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecGlobalSecondaryIndexesKeySchema(obj: TableSpecGlobalSecondaryIndexesKeySchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
 *
 * @schema TableSpecGlobalSecondaryIndexesProjection
 */
export interface TableSpecGlobalSecondaryIndexesProjection {
  /**
   * @schema TableSpecGlobalSecondaryIndexesProjection#nonKeyAttributes
   */
  readonly nonKeyAttributes?: string[];

  /**
   * @schema TableSpecGlobalSecondaryIndexesProjection#projectionType
   */
  readonly projectionType?: string;

}

/**
 * Converts an object of type 'TableSpecGlobalSecondaryIndexesProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecGlobalSecondaryIndexesProjection(obj: TableSpecGlobalSecondaryIndexesProjection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nonKeyAttributes': obj.nonKeyAttributes?.map(y => y),
    'projectionType': obj.projectionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
 * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
 *
 * @schema TableSpecGlobalSecondaryIndexesProvisionedThroughput
 */
export interface TableSpecGlobalSecondaryIndexesProvisionedThroughput {
  /**
   * @schema TableSpecGlobalSecondaryIndexesProvisionedThroughput#readCapacityUnits
   */
  readonly readCapacityUnits?: number;

  /**
   * @schema TableSpecGlobalSecondaryIndexesProvisionedThroughput#writeCapacityUnits
   */
  readonly writeCapacityUnits?: number;

}

/**
 * Converts an object of type 'TableSpecGlobalSecondaryIndexesProvisionedThroughput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecGlobalSecondaryIndexesProvisionedThroughput(obj: TableSpecGlobalSecondaryIndexesProvisionedThroughput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readCapacityUnits': obj.readCapacityUnits,
    'writeCapacityUnits': obj.writeCapacityUnits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents a single element of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index.
 * A KeySchemaElement represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one KeySchemaElement (for the partition key). A composite primary key would require one KeySchemaElement for the partition key, and another KeySchemaElement for the sort key.
 * A KeySchemaElement must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.
 *
 * @schema TableSpecLocalSecondaryIndexesKeySchema
 */
export interface TableSpecLocalSecondaryIndexesKeySchema {
  /**
   * @schema TableSpecLocalSecondaryIndexesKeySchema#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecLocalSecondaryIndexesKeySchema#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'TableSpecLocalSecondaryIndexesKeySchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecLocalSecondaryIndexesKeySchema(obj: TableSpecLocalSecondaryIndexesKeySchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
 *
 * @schema TableSpecLocalSecondaryIndexesProjection
 */
export interface TableSpecLocalSecondaryIndexesProjection {
  /**
   * @schema TableSpecLocalSecondaryIndexesProjection#nonKeyAttributes
   */
  readonly nonKeyAttributes?: string[];

  /**
   * @schema TableSpecLocalSecondaryIndexesProjection#projectionType
   */
  readonly projectionType?: string;

}

/**
 * Converts an object of type 'TableSpecLocalSecondaryIndexesProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecLocalSecondaryIndexesProjection(obj: TableSpecLocalSecondaryIndexesProjection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nonKeyAttributes': obj.nonKeyAttributes?.map(y => y),
    'projectionType': obj.projectionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

