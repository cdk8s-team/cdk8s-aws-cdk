// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the Buckets API
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.services.k8s.aws/v1alpha1',
    kind: 'Bucket',
  };

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps = {}): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps = {}) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the Buckets API
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of Bucket.
   * In terms of implementation, a Bucket is a resource. An Amazon S3 bucket name is globally unique, and the namespace is shared by all Amazon Web Services accounts.
   *
   * @schema Bucket#spec
   */
  readonly spec?: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec defines the desired state of Bucket.
 * In terms of implementation, a Bucket is a resource. An Amazon S3 bucket name is globally unique, and the namespace is shared by all Amazon Web Services accounts.
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * Container for setting the transfer acceleration state.
   *
   * @schema BucketSpec#accelerate
   */
  readonly accelerate?: BucketSpecAccelerate;

  /**
   * The canned ACL to apply to the bucket.
   *
   * @schema BucketSpec#acl
   */
  readonly acl?: string;

  /**
   * @schema BucketSpec#analytics
   */
  readonly analytics?: BucketSpecAnalytics[];

  /**
   * Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see Enabling Cross-Origin Resource Sharing (https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon S3 User Guide.
   *
   * @schema BucketSpec#cors
   */
  readonly cors?: BucketSpecCors;

  /**
   * The configuration information for the bucket.
   *
   * @schema BucketSpec#createBucketConfiguration
   */
  readonly createBucketConfiguration?: BucketSpecCreateBucketConfiguration;

  /**
   * Specifies the default server-side-encryption configuration.
   *
   * @schema BucketSpec#encryption
   */
  readonly encryption?: BucketSpecEncryption;

  /**
   * Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
   *
   * @schema BucketSpec#grantFullControl
   */
  readonly grantFullControl?: string;

  /**
   * Allows grantee to list the objects in the bucket.
   *
   * @schema BucketSpec#grantRead
   */
  readonly grantRead?: string;

  /**
   * Allows grantee to read the bucket ACL.
   *
   * @schema BucketSpec#grantReadACP
   */
  readonly grantReadAcp?: string;

  /**
   * Allows grantee to create new objects in the bucket.
   * For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.
   *
   * @schema BucketSpec#grantWrite
   */
  readonly grantWrite?: string;

  /**
   * Allows grantee to write the ACL for the applicable bucket.
   *
   * @schema BucketSpec#grantWriteACP
   */
  readonly grantWriteAcp?: string;

  /**
   * @schema BucketSpec#intelligentTiering
   */
  readonly intelligentTiering?: BucketSpecIntelligentTiering[];

  /**
   * @schema BucketSpec#inventory
   */
  readonly inventory?: BucketSpecInventory[];

  /**
   * Container for lifecycle rules. You can add as many as 1,000 rules.
   *
   * @schema BucketSpec#lifecycle
   */
  readonly lifecycle?: BucketSpecLifecycle;

  /**
   * Container for logging status information.
   *
   * @schema BucketSpec#logging
   */
  readonly logging?: BucketSpecLogging;

  /**
   * @schema BucketSpec#metrics
   */
  readonly metrics?: BucketSpecMetrics[];

  /**
   * The name of the bucket to create.
   *
   * @schema BucketSpec#name
   */
  readonly name: string;

  /**
   * A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.
   *
   * @schema BucketSpec#notification
   */
  readonly notification?: BucketSpecNotification;

  /**
   * Specifies whether you want S3 Object Lock to be enabled for the new bucket.
   *
   * @schema BucketSpec#objectLockEnabledForBucket
   */
  readonly objectLockEnabledForBucket?: boolean;

  /**
   * The OwnershipControls (BucketOwnerPreferred or ObjectWriter) that you want to apply to this Amazon S3 bucket.
   *
   * @schema BucketSpec#ownershipControls
   */
  readonly ownershipControls?: BucketSpecOwnershipControls;

  /**
   * The bucket policy as a JSON document.
   *
   * @schema BucketSpec#policy
   */
  readonly policy?: string;

  /**
   * The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see The Meaning of "Public" (https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
   *
   * @schema BucketSpec#publicAccessBlock
   */
  readonly publicAccessBlock?: BucketSpecPublicAccessBlock;

  /**
   * A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
   *
   * @schema BucketSpec#replication
   */
  readonly replication?: BucketSpecReplication;

  /**
   * Container for Payer.
   *
   * @schema BucketSpec#requestPayment
   */
  readonly requestPayment?: BucketSpecRequestPayment;

  /**
   * Container for the TagSet and Tag elements.
   *
   * @schema BucketSpec#tagging
   */
  readonly tagging?: BucketSpecTagging;

  /**
   * Container for setting the versioning state.
   *
   * @schema BucketSpec#versioning
   */
  readonly versioning?: BucketSpecVersioning;

  /**
   * Container for the request.
   *
   * @schema BucketSpec#website
   */
  readonly website?: BucketSpecWebsite;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accelerate': toJson_BucketSpecAccelerate(obj.accelerate),
    'acl': obj.acl,
    'analytics': obj.analytics?.map(y => toJson_BucketSpecAnalytics(y)),
    'cors': toJson_BucketSpecCors(obj.cors),
    'createBucketConfiguration': toJson_BucketSpecCreateBucketConfiguration(obj.createBucketConfiguration),
    'encryption': toJson_BucketSpecEncryption(obj.encryption),
    'grantFullControl': obj.grantFullControl,
    'grantRead': obj.grantRead,
    'grantReadACP': obj.grantReadAcp,
    'grantWrite': obj.grantWrite,
    'grantWriteACP': obj.grantWriteAcp,
    'intelligentTiering': obj.intelligentTiering?.map(y => toJson_BucketSpecIntelligentTiering(y)),
    'inventory': obj.inventory?.map(y => toJson_BucketSpecInventory(y)),
    'lifecycle': toJson_BucketSpecLifecycle(obj.lifecycle),
    'logging': toJson_BucketSpecLogging(obj.logging),
    'metrics': obj.metrics?.map(y => toJson_BucketSpecMetrics(y)),
    'name': obj.name,
    'notification': toJson_BucketSpecNotification(obj.notification),
    'objectLockEnabledForBucket': obj.objectLockEnabledForBucket,
    'ownershipControls': toJson_BucketSpecOwnershipControls(obj.ownershipControls),
    'policy': obj.policy,
    'publicAccessBlock': toJson_BucketSpecPublicAccessBlock(obj.publicAccessBlock),
    'replication': toJson_BucketSpecReplication(obj.replication),
    'requestPayment': toJson_BucketSpecRequestPayment(obj.requestPayment),
    'tagging': toJson_BucketSpecTagging(obj.tagging),
    'versioning': toJson_BucketSpecVersioning(obj.versioning),
    'website': toJson_BucketSpecWebsite(obj.website),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for setting the transfer acceleration state.
 *
 * @schema BucketSpecAccelerate
 */
export interface BucketSpecAccelerate {
  /**
   * @schema BucketSpecAccelerate#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecAccelerate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAccelerate(obj: BucketSpecAccelerate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
 *
 * @schema BucketSpecAnalytics
 */
export interface BucketSpecAnalytics {
  /**
   * The filter used to describe a set of objects for analyses. A filter must have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided, all objects will be considered in any analysis.
   *
   * @schema BucketSpecAnalytics#filter
   */
  readonly filter?: BucketSpecAnalyticsFilter;

  /**
   * @schema BucketSpecAnalytics#id
   */
  readonly id?: string;

  /**
   * Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
   *
   * @schema BucketSpecAnalytics#storageClassAnalysis
   */
  readonly storageClassAnalysis?: BucketSpecAnalyticsStorageClassAnalysis;

}

/**
 * Converts an object of type 'BucketSpecAnalytics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalytics(obj: BucketSpecAnalytics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': toJson_BucketSpecAnalyticsFilter(obj.filter),
    'id': obj.id,
    'storageClassAnalysis': toJson_BucketSpecAnalyticsStorageClassAnalysis(obj.storageClassAnalysis),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see Enabling Cross-Origin Resource Sharing (https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecCors
 */
export interface BucketSpecCors {
  /**
   * @schema BucketSpecCors#corsRules
   */
  readonly corsRules?: BucketSpecCorsCorsRules[];

}

/**
 * Converts an object of type 'BucketSpecCors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecCors(obj: BucketSpecCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsRules': obj.corsRules?.map(y => toJson_BucketSpecCorsCorsRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration information for the bucket.
 *
 * @schema BucketSpecCreateBucketConfiguration
 */
export interface BucketSpecCreateBucketConfiguration {
  /**
   * @schema BucketSpecCreateBucketConfiguration#locationConstraint
   */
  readonly locationConstraint?: string;

}

/**
 * Converts an object of type 'BucketSpecCreateBucketConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecCreateBucketConfiguration(obj: BucketSpecCreateBucketConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locationConstraint': obj.locationConstraint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the default server-side-encryption configuration.
 *
 * @schema BucketSpecEncryption
 */
export interface BucketSpecEncryption {
  /**
   * @schema BucketSpecEncryption#rules
   */
  readonly rules?: BucketSpecEncryptionRules[];

}

/**
 * Converts an object of type 'BucketSpecEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecEncryption(obj: BucketSpecEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BucketSpecEncryptionRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket.
 * For information about the S3 Intelligent-Tiering storage class, see Storage class for automatically optimizing frequently and infrequently accessed objects (https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access).
 *
 * @schema BucketSpecIntelligentTiering
 */
export interface BucketSpecIntelligentTiering {
  /**
   * The Filter is used to identify objects that the S3 Intelligent-Tiering configuration applies to.
   *
   * @schema BucketSpecIntelligentTiering#filter
   */
  readonly filter?: BucketSpecIntelligentTieringFilter;

  /**
   * @schema BucketSpecIntelligentTiering#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecIntelligentTiering#status
   */
  readonly status?: string;

  /**
   * @schema BucketSpecIntelligentTiering#tierings
   */
  readonly tierings?: BucketSpecIntelligentTieringTierings[];

}

/**
 * Converts an object of type 'BucketSpecIntelligentTiering' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecIntelligentTiering(obj: BucketSpecIntelligentTiering | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': toJson_BucketSpecIntelligentTieringFilter(obj.filter),
    'id': obj.id,
    'status': obj.status,
    'tierings': obj.tierings?.map(y => toJson_BucketSpecIntelligentTieringTierings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the inventory configuration for an Amazon S3 bucket. For more information, see GET Bucket inventory (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html) in the Amazon S3 API Reference.
 *
 * @schema BucketSpecInventory
 */
export interface BucketSpecInventory {
  /**
   * Specifies the inventory configuration for an Amazon S3 bucket.
   *
   * @schema BucketSpecInventory#destination
   */
  readonly destination?: BucketSpecInventoryDestination;

  /**
   * Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria.
   *
   * @schema BucketSpecInventory#filter
   */
  readonly filter?: BucketSpecInventoryFilter;

  /**
   * @schema BucketSpecInventory#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecInventory#includedObjectVersions
   */
  readonly includedObjectVersions?: string;

  /**
   * @schema BucketSpecInventory#isEnabled
   */
  readonly isEnabled?: boolean;

  /**
   * @schema BucketSpecInventory#optionalFields
   */
  readonly optionalFields?: string[];

  /**
   * Specifies the schedule for generating inventory results.
   *
   * @schema BucketSpecInventory#schedule
   */
  readonly schedule?: BucketSpecInventorySchedule;

}

/**
 * Converts an object of type 'BucketSpecInventory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventory(obj: BucketSpecInventory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_BucketSpecInventoryDestination(obj.destination),
    'filter': toJson_BucketSpecInventoryFilter(obj.filter),
    'id': obj.id,
    'includedObjectVersions': obj.includedObjectVersions,
    'isEnabled': obj.isEnabled,
    'optionalFields': obj.optionalFields?.map(y => y),
    'schedule': toJson_BucketSpecInventorySchedule(obj.schedule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for lifecycle rules. You can add as many as 1,000 rules.
 *
 * @schema BucketSpecLifecycle
 */
export interface BucketSpecLifecycle {
  /**
   * @schema BucketSpecLifecycle#rules
   */
  readonly rules?: BucketSpecLifecycleRules[];

}

/**
 * Converts an object of type 'BucketSpecLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycle(obj: BucketSpecLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BucketSpecLifecycleRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for logging status information.
 *
 * @schema BucketSpecLogging
 */
export interface BucketSpecLogging {
  /**
   * Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For more information, see PUT Bucket logging (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the Amazon S3 API Reference.
   *
   * @schema BucketSpecLogging#loggingEnabled
   */
  readonly loggingEnabled?: BucketSpecLoggingLoggingEnabled;

}

/**
 * Converts an object of type 'BucketSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLogging(obj: BucketSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggingEnabled': toJson_BucketSpecLoggingLoggingEnabled(obj.loggingEnabled),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket. If you're updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don't include the elements you want to keep, they are erased. For more information, see PutBucketMetricsConfiguration (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html).
 *
 * @schema BucketSpecMetrics
 */
export interface BucketSpecMetrics {
  /**
   * Specifies a metrics configuration filter. The metrics configuration only includes objects that meet the filter's criteria. A filter must be a prefix, an object tag, an access point ARN, or a conjunction (MetricsAndOperator). For more information, see PutBucketMetricsConfiguration (https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketMetricsConfiguration.html).
   *
   * @schema BucketSpecMetrics#filter
   */
  readonly filter?: BucketSpecMetricsFilter;

  /**
   * @schema BucketSpecMetrics#id
   */
  readonly id?: string;

}

/**
 * Converts an object of type 'BucketSpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecMetrics(obj: BucketSpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': toJson_BucketSpecMetricsFilter(obj.filter),
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.
 *
 * @schema BucketSpecNotification
 */
export interface BucketSpecNotification {
  /**
   * @schema BucketSpecNotification#lambdaFunctionConfigurations
   */
  readonly lambdaFunctionConfigurations?: BucketSpecNotificationLambdaFunctionConfigurations[];

  /**
   * @schema BucketSpecNotification#queueConfigurations
   */
  readonly queueConfigurations?: BucketSpecNotificationQueueConfigurations[];

  /**
   * @schema BucketSpecNotification#topicConfigurations
   */
  readonly topicConfigurations?: BucketSpecNotificationTopicConfigurations[];

}

/**
 * Converts an object of type 'BucketSpecNotification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotification(obj: BucketSpecNotification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaFunctionConfigurations': obj.lambdaFunctionConfigurations?.map(y => toJson_BucketSpecNotificationLambdaFunctionConfigurations(y)),
    'queueConfigurations': obj.queueConfigurations?.map(y => toJson_BucketSpecNotificationQueueConfigurations(y)),
    'topicConfigurations': obj.topicConfigurations?.map(y => toJson_BucketSpecNotificationTopicConfigurations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The OwnershipControls (BucketOwnerPreferred or ObjectWriter) that you want to apply to this Amazon S3 bucket.
 *
 * @schema BucketSpecOwnershipControls
 */
export interface BucketSpecOwnershipControls {
  /**
   * @schema BucketSpecOwnershipControls#rules
   */
  readonly rules?: BucketSpecOwnershipControlsRules[];

}

/**
 * Converts an object of type 'BucketSpecOwnershipControls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecOwnershipControls(obj: BucketSpecOwnershipControls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BucketSpecOwnershipControlsRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see The Meaning of "Public" (https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecPublicAccessBlock
 */
export interface BucketSpecPublicAccessBlock {
  /**
   * @schema BucketSpecPublicAccessBlock#blockPublicACLs
   */
  readonly blockPublicAcLs?: boolean;

  /**
   * @schema BucketSpecPublicAccessBlock#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * @schema BucketSpecPublicAccessBlock#ignorePublicACLs
   */
  readonly ignorePublicAcLs?: boolean;

  /**
   * @schema BucketSpecPublicAccessBlock#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'BucketSpecPublicAccessBlock' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublicAccessBlock(obj: BucketSpecPublicAccessBlock | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicACLs': obj.blockPublicAcLs,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'ignorePublicACLs': obj.ignorePublicAcLs,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
 *
 * @schema BucketSpecReplication
 */
export interface BucketSpecReplication {
  /**
   * @schema BucketSpecReplication#role
   */
  readonly role?: string;

  /**
   * @schema BucketSpecReplication#rules
   */
  readonly rules?: BucketSpecReplicationRules[];

}

/**
 * Converts an object of type 'BucketSpecReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplication(obj: BucketSpecReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'role': obj.role,
    'rules': obj.rules?.map(y => toJson_BucketSpecReplicationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for Payer.
 *
 * @schema BucketSpecRequestPayment
 */
export interface BucketSpecRequestPayment {
  /**
   * @schema BucketSpecRequestPayment#payer
   */
  readonly payer?: string;

}

/**
 * Converts an object of type 'BucketSpecRequestPayment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecRequestPayment(obj: BucketSpecRequestPayment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'payer': obj.payer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the TagSet and Tag elements.
 *
 * @schema BucketSpecTagging
 */
export interface BucketSpecTagging {
  /**
   * @schema BucketSpecTagging#tagSet
   */
  readonly tagSet?: BucketSpecTaggingTagSet[];

}

/**
 * Converts an object of type 'BucketSpecTagging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecTagging(obj: BucketSpecTagging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tagSet': obj.tagSet?.map(y => toJson_BucketSpecTaggingTagSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for setting the versioning state.
 *
 * @schema BucketSpecVersioning
 */
export interface BucketSpecVersioning {
  /**
   * @schema BucketSpecVersioning#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecVersioning' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecVersioning(obj: BucketSpecVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the request.
 *
 * @schema BucketSpecWebsite
 */
export interface BucketSpecWebsite {
  /**
   * The error information.
   *
   * @schema BucketSpecWebsite#errorDocument
   */
  readonly errorDocument?: BucketSpecWebsiteErrorDocument;

  /**
   * Container for the Suffix element.
   *
   * @schema BucketSpecWebsite#indexDocument
   */
  readonly indexDocument?: BucketSpecWebsiteIndexDocument;

  /**
   * Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
   *
   * @schema BucketSpecWebsite#redirectAllRequestsTo
   */
  readonly redirectAllRequestsTo?: BucketSpecWebsiteRedirectAllRequestsTo;

  /**
   * @schema BucketSpecWebsite#routingRules
   */
  readonly routingRules?: BucketSpecWebsiteRoutingRules[];

}

/**
 * Converts an object of type 'BucketSpecWebsite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsite(obj: BucketSpecWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorDocument': toJson_BucketSpecWebsiteErrorDocument(obj.errorDocument),
    'indexDocument': toJson_BucketSpecWebsiteIndexDocument(obj.indexDocument),
    'redirectAllRequestsTo': toJson_BucketSpecWebsiteRedirectAllRequestsTo(obj.redirectAllRequestsTo),
    'routingRules': obj.routingRules?.map(y => toJson_BucketSpecWebsiteRoutingRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The filter used to describe a set of objects for analyses. A filter must have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided, all objects will be considered in any analysis.
 *
 * @schema BucketSpecAnalyticsFilter
 */
export interface BucketSpecAnalyticsFilter {
  /**
   * A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates in any combination, and an object must match all of the predicates for the filter to apply.
   *
   * @schema BucketSpecAnalyticsFilter#and
   */
  readonly and?: BucketSpecAnalyticsFilterAnd;

  /**
   * @schema BucketSpecAnalyticsFilter#prefix
   */
  readonly prefix?: string;

  /**
   * A container of a key value name pair.
   *
   * @schema BucketSpecAnalyticsFilter#tag
   */
  readonly tag?: BucketSpecAnalyticsFilterTag;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsFilter(obj: BucketSpecAnalyticsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': toJson_BucketSpecAnalyticsFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecAnalyticsFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
 *
 * @schema BucketSpecAnalyticsStorageClassAnalysis
 */
export interface BucketSpecAnalyticsStorageClassAnalysis {
  /**
   * Container for data related to the storage class analysis for an Amazon S3 bucket for export.
   *
   * @schema BucketSpecAnalyticsStorageClassAnalysis#dataExport
   */
  readonly dataExport?: BucketSpecAnalyticsStorageClassAnalysisDataExport;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsStorageClassAnalysis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsStorageClassAnalysis(obj: BucketSpecAnalyticsStorageClassAnalysis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataExport': toJson_BucketSpecAnalyticsStorageClassAnalysisDataExport(obj.dataExport),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a cross-origin access rule for an Amazon S3 bucket.
 *
 * @schema BucketSpecCorsCorsRules
 */
export interface BucketSpecCorsCorsRules {
  /**
   * @schema BucketSpecCorsCorsRules#allowedHeaders
   */
  readonly allowedHeaders?: string[];

  /**
   * @schema BucketSpecCorsCorsRules#allowedMethods
   */
  readonly allowedMethods?: string[];

  /**
   * @schema BucketSpecCorsCorsRules#allowedOrigins
   */
  readonly allowedOrigins?: string[];

  /**
   * @schema BucketSpecCorsCorsRules#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * @schema BucketSpecCorsCorsRules#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecCorsCorsRules#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

}

/**
 * Converts an object of type 'BucketSpecCorsCorsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecCorsCorsRules(obj: BucketSpecCorsCorsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedHeaders': obj.allowedHeaders?.map(y => y),
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'allowedOrigins': obj.allowedOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'id': obj.id,
    'maxAgeSeconds': obj.maxAgeSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the default server-side encryption configuration.
 *
 * @schema BucketSpecEncryptionRules
 */
export interface BucketSpecEncryptionRules {
  /**
   * Describes the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. For more information, see PUT Bucket encryption (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the Amazon S3 API Reference.
   *
   * @schema BucketSpecEncryptionRules#applyServerSideEncryptionByDefault
   */
  readonly applyServerSideEncryptionByDefault?: BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault;

  /**
   * @schema BucketSpecEncryptionRules#bucketKeyEnabled
   */
  readonly bucketKeyEnabled?: boolean;

}

/**
 * Converts an object of type 'BucketSpecEncryptionRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecEncryptionRules(obj: BucketSpecEncryptionRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyServerSideEncryptionByDefault': toJson_BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault(obj.applyServerSideEncryptionByDefault),
    'bucketKeyEnabled': obj.bucketKeyEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Filter is used to identify objects that the S3 Intelligent-Tiering configuration applies to.
 *
 * @schema BucketSpecIntelligentTieringFilter
 */
export interface BucketSpecIntelligentTieringFilter {
  /**
   * A container for specifying S3 Intelligent-Tiering filters. The filters determine the subset of objects to which the rule applies.
   *
   * @schema BucketSpecIntelligentTieringFilter#and
   */
  readonly and?: BucketSpecIntelligentTieringFilterAnd;

  /**
   * @schema BucketSpecIntelligentTieringFilter#prefix
   */
  readonly prefix?: string;

  /**
   * A container of a key value name pair.
   *
   * @schema BucketSpecIntelligentTieringFilter#tag
   */
  readonly tag?: BucketSpecIntelligentTieringFilterTag;

}

/**
 * Converts an object of type 'BucketSpecIntelligentTieringFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecIntelligentTieringFilter(obj: BucketSpecIntelligentTieringFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': toJson_BucketSpecIntelligentTieringFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecIntelligentTieringFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The S3 Intelligent-Tiering storage class is designed to optimize storage costs by automatically moving data to the most cost-effective storage access tier, without additional operational overhead.
 *
 * @schema BucketSpecIntelligentTieringTierings
 */
export interface BucketSpecIntelligentTieringTierings {
  /**
   * @schema BucketSpecIntelligentTieringTierings#accessTier
   */
  readonly accessTier?: string;

  /**
   * @schema BucketSpecIntelligentTieringTierings#days
   */
  readonly days?: number;

}

/**
 * Converts an object of type 'BucketSpecIntelligentTieringTierings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecIntelligentTieringTierings(obj: BucketSpecIntelligentTieringTierings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTier': obj.accessTier,
    'days': obj.days,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the inventory configuration for an Amazon S3 bucket.
 *
 * @schema BucketSpecInventoryDestination
 */
export interface BucketSpecInventoryDestination {
  /**
   * Contains the bucket name, file format, bucket owner (optional), and prefix (optional) where inventory results are published.
   *
   * @schema BucketSpecInventoryDestination#s3BucketDestination
   */
  readonly s3BucketDestination?: BucketSpecInventoryDestinationS3BucketDestination;

}

/**
 * Converts an object of type 'BucketSpecInventoryDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventoryDestination(obj: BucketSpecInventoryDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3BucketDestination': toJson_BucketSpecInventoryDestinationS3BucketDestination(obj.s3BucketDestination),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria.
 *
 * @schema BucketSpecInventoryFilter
 */
export interface BucketSpecInventoryFilter {
  /**
   * @schema BucketSpecInventoryFilter#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'BucketSpecInventoryFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventoryFilter(obj: BucketSpecInventoryFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the schedule for generating inventory results.
 *
 * @schema BucketSpecInventorySchedule
 */
export interface BucketSpecInventorySchedule {
  /**
   * @schema BucketSpecInventorySchedule#frequency
   */
  readonly frequency?: string;

}

/**
 * Converts an object of type 'BucketSpecInventorySchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventorySchedule(obj: BucketSpecInventorySchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequency': obj.frequency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A lifecycle rule for individual objects in an Amazon S3 bucket.
 *
 * @schema BucketSpecLifecycleRules
 */
export interface BucketSpecLifecycleRules {
  /**
   * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
   *
   * @schema BucketSpecLifecycleRules#abortIncompleteMultipartUpload
   */
  readonly abortIncompleteMultipartUpload?: BucketSpecLifecycleRulesAbortIncompleteMultipartUpload;

  /**
   * Container for the expiration for the lifecycle of the object.
   *
   * @schema BucketSpecLifecycleRules#expiration
   */
  readonly expiration?: BucketSpecLifecycleRulesExpiration;

  /**
   * The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified.
   *
   * @schema BucketSpecLifecycleRules#filter
   */
  readonly filter?: BucketSpecLifecycleRulesFilter;

  /**
   * @schema BucketSpecLifecycleRules#id
   */
  readonly id?: string;

  /**
   * Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
   *
   * @schema BucketSpecLifecycleRules#noncurrentVersionExpiration
   */
  readonly noncurrentVersionExpiration?: BucketSpecLifecycleRulesNoncurrentVersionExpiration;

  /**
   * @schema BucketSpecLifecycleRules#noncurrentVersionTransitions
   */
  readonly noncurrentVersionTransitions?: BucketSpecLifecycleRulesNoncurrentVersionTransitions[];

  /**
   * @schema BucketSpecLifecycleRules#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecLifecycleRules#status
   */
  readonly status?: string;

  /**
   * @schema BucketSpecLifecycleRules#transitions
   */
  readonly transitions?: BucketSpecLifecycleRulesTransitions[];

}

/**
 * Converts an object of type 'BucketSpecLifecycleRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRules(obj: BucketSpecLifecycleRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abortIncompleteMultipartUpload': toJson_BucketSpecLifecycleRulesAbortIncompleteMultipartUpload(obj.abortIncompleteMultipartUpload),
    'expiration': toJson_BucketSpecLifecycleRulesExpiration(obj.expiration),
    'filter': toJson_BucketSpecLifecycleRulesFilter(obj.filter),
    'id': obj.id,
    'noncurrentVersionExpiration': toJson_BucketSpecLifecycleRulesNoncurrentVersionExpiration(obj.noncurrentVersionExpiration),
    'noncurrentVersionTransitions': obj.noncurrentVersionTransitions?.map(y => toJson_BucketSpecLifecycleRulesNoncurrentVersionTransitions(y)),
    'prefix': obj.prefix,
    'status': obj.status,
    'transitions': obj.transitions?.map(y => toJson_BucketSpecLifecycleRulesTransitions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For more information, see PUT Bucket logging (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the Amazon S3 API Reference.
 *
 * @schema BucketSpecLoggingLoggingEnabled
 */
export interface BucketSpecLoggingLoggingEnabled {
  /**
   * @schema BucketSpecLoggingLoggingEnabled#targetBucket
   */
  readonly targetBucket?: string;

  /**
   * @schema BucketSpecLoggingLoggingEnabled#targetGrants
   */
  readonly targetGrants?: BucketSpecLoggingLoggingEnabledTargetGrants[];

  /**
   * @schema BucketSpecLoggingLoggingEnabled#targetPrefix
   */
  readonly targetPrefix?: string;

}

/**
 * Converts an object of type 'BucketSpecLoggingLoggingEnabled' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLoggingLoggingEnabled(obj: BucketSpecLoggingLoggingEnabled | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetBucket': obj.targetBucket,
    'targetGrants': obj.targetGrants?.map(y => toJson_BucketSpecLoggingLoggingEnabledTargetGrants(y)),
    'targetPrefix': obj.targetPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a metrics configuration filter. The metrics configuration only includes objects that meet the filter's criteria. A filter must be a prefix, an object tag, an access point ARN, or a conjunction (MetricsAndOperator). For more information, see PutBucketMetricsConfiguration (https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketMetricsConfiguration.html).
 *
 * @schema BucketSpecMetricsFilter
 */
export interface BucketSpecMetricsFilter {
  /**
   * @schema BucketSpecMetricsFilter#accessPointARN
   */
  readonly accessPointArn?: string;

  /**
   * A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply.
   *
   * @schema BucketSpecMetricsFilter#and
   */
  readonly and?: BucketSpecMetricsFilterAnd;

  /**
   * @schema BucketSpecMetricsFilter#prefix
   */
  readonly prefix?: string;

  /**
   * A container of a key value name pair.
   *
   * @schema BucketSpecMetricsFilter#tag
   */
  readonly tag?: BucketSpecMetricsFilterTag;

}

/**
 * Converts an object of type 'BucketSpecMetricsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecMetricsFilter(obj: BucketSpecMetricsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPointARN': obj.accessPointArn,
    'and': toJson_BucketSpecMetricsFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecMetricsFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for specifying the configuration for Lambda notifications.
 *
 * @schema BucketSpecNotificationLambdaFunctionConfigurations
 */
export interface BucketSpecNotificationLambdaFunctionConfigurations {
  /**
   * @schema BucketSpecNotificationLambdaFunctionConfigurations#events
   */
  readonly events?: string[];

  /**
   * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
   *
   * @schema BucketSpecNotificationLambdaFunctionConfigurations#filter
   */
  readonly filter?: BucketSpecNotificationLambdaFunctionConfigurationsFilter;

  /**
   * An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
   *
   * @schema BucketSpecNotificationLambdaFunctionConfigurations#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecNotificationLambdaFunctionConfigurations#lambdaFunctionARN
   */
  readonly lambdaFunctionArn?: string;

}

/**
 * Converts an object of type 'BucketSpecNotificationLambdaFunctionConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationLambdaFunctionConfigurations(obj: BucketSpecNotificationLambdaFunctionConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'filter': toJson_BucketSpecNotificationLambdaFunctionConfigurationsFilter(obj.filter),
    'id': obj.id,
    'lambdaFunctionARN': obj.lambdaFunctionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the configuration for publishing messages to an Amazon Simple Queue Service (Amazon SQS) queue when Amazon S3 detects specified events.
 *
 * @schema BucketSpecNotificationQueueConfigurations
 */
export interface BucketSpecNotificationQueueConfigurations {
  /**
   * @schema BucketSpecNotificationQueueConfigurations#events
   */
  readonly events?: string[];

  /**
   * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
   *
   * @schema BucketSpecNotificationQueueConfigurations#filter
   */
  readonly filter?: BucketSpecNotificationQueueConfigurationsFilter;

  /**
   * An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
   *
   * @schema BucketSpecNotificationQueueConfigurations#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecNotificationQueueConfigurations#queueARN
   */
  readonly queueArn?: string;

}

/**
 * Converts an object of type 'BucketSpecNotificationQueueConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationQueueConfigurations(obj: BucketSpecNotificationQueueConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'filter': toJson_BucketSpecNotificationQueueConfigurationsFilter(obj.filter),
    'id': obj.id,
    'queueARN': obj.queueArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for specifying the configuration for publication of messages to an Amazon Simple Notification Service (Amazon SNS) topic when Amazon S3 detects specified events.
 *
 * @schema BucketSpecNotificationTopicConfigurations
 */
export interface BucketSpecNotificationTopicConfigurations {
  /**
   * @schema BucketSpecNotificationTopicConfigurations#events
   */
  readonly events?: string[];

  /**
   * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
   *
   * @schema BucketSpecNotificationTopicConfigurations#filter
   */
  readonly filter?: BucketSpecNotificationTopicConfigurationsFilter;

  /**
   * An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.
   *
   * @schema BucketSpecNotificationTopicConfigurations#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecNotificationTopicConfigurations#topicARN
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'BucketSpecNotificationTopicConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationTopicConfigurations(obj: BucketSpecNotificationTopicConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'filter': toJson_BucketSpecNotificationTopicConfigurationsFilter(obj.filter),
    'id': obj.id,
    'topicARN': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The container element for an ownership control rule.
 *
 * @schema BucketSpecOwnershipControlsRules
 */
export interface BucketSpecOwnershipControlsRules {
  /**
   * The container element for object ownership for a bucket's ownership controls.
   * BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the bucket-owner-full-control canned ACL.
   * ObjectWriter - The uploading account will own the object if the object is uploaded with the bucket-owner-full-control canned ACL.
   *
   * @schema BucketSpecOwnershipControlsRules#objectOwnership
   */
  readonly objectOwnership?: string;

}

/**
 * Converts an object of type 'BucketSpecOwnershipControlsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecOwnershipControlsRules(obj: BucketSpecOwnershipControlsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectOwnership': obj.objectOwnership,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies which Amazon S3 objects to replicate and where to store the replicas.
 *
 * @schema BucketSpecReplicationRules
 */
export interface BucketSpecReplicationRules {
  /**
   * Specifies whether Amazon S3 replicates delete markers. If you specify a Filter in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication Status must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).
   * For more information about delete marker replication, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html).
   * If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see Backward Compatibility (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
   *
   * @schema BucketSpecReplicationRules#deleteMarkerReplication
   */
  readonly deleteMarkerReplication?: BucketSpecReplicationRulesDeleteMarkerReplication;

  /**
   * Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
   *
   * @schema BucketSpecReplicationRules#destination
   */
  readonly destination?: BucketSpecReplicationRulesDestination;

  /**
   * Optional configuration to replicate existing source bucket objects. For more information, see Replicating Existing Objects (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication) in the Amazon S3 User Guide.
   *
   * @schema BucketSpecReplicationRules#existingObjectReplication
   */
  readonly existingObjectReplication?: BucketSpecReplicationRulesExistingObjectReplication;

  /**
   * A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
   *
   * @schema BucketSpecReplicationRules#filter
   */
  readonly filter?: BucketSpecReplicationRulesFilter;

  /**
   * @schema BucketSpecReplicationRules#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecReplicationRules#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecReplicationRules#priority
   */
  readonly priority?: number;

  /**
   * A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer managed key stored in Amazon Web Services Key Management Service (SSE-KMS).
   *
   * @schema BucketSpecReplicationRules#sourceSelectionCriteria
   */
  readonly sourceSelectionCriteria?: BucketSpecReplicationRulesSourceSelectionCriteria;

  /**
   * @schema BucketSpecReplicationRules#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRules(obj: BucketSpecReplicationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteMarkerReplication': toJson_BucketSpecReplicationRulesDeleteMarkerReplication(obj.deleteMarkerReplication),
    'destination': toJson_BucketSpecReplicationRulesDestination(obj.destination),
    'existingObjectReplication': toJson_BucketSpecReplicationRulesExistingObjectReplication(obj.existingObjectReplication),
    'filter': toJson_BucketSpecReplicationRulesFilter(obj.filter),
    'id': obj.id,
    'prefix': obj.prefix,
    'priority': obj.priority,
    'sourceSelectionCriteria': toJson_BucketSpecReplicationRulesSourceSelectionCriteria(obj.sourceSelectionCriteria),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecTaggingTagSet
 */
export interface BucketSpecTaggingTagSet {
  /**
   * @schema BucketSpecTaggingTagSet#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecTaggingTagSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecTaggingTagSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecTaggingTagSet(obj: BucketSpecTaggingTagSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The error information.
 *
 * @schema BucketSpecWebsiteErrorDocument
 */
export interface BucketSpecWebsiteErrorDocument {
  /**
   * @schema BucketSpecWebsiteErrorDocument#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'BucketSpecWebsiteErrorDocument' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsiteErrorDocument(obj: BucketSpecWebsiteErrorDocument | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the Suffix element.
 *
 * @schema BucketSpecWebsiteIndexDocument
 */
export interface BucketSpecWebsiteIndexDocument {
  /**
   * @schema BucketSpecWebsiteIndexDocument#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'BucketSpecWebsiteIndexDocument' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsiteIndexDocument(obj: BucketSpecWebsiteIndexDocument | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
 *
 * @schema BucketSpecWebsiteRedirectAllRequestsTo
 */
export interface BucketSpecWebsiteRedirectAllRequestsTo {
  /**
   * @schema BucketSpecWebsiteRedirectAllRequestsTo#hostName
   */
  readonly hostName?: string;

  /**
   * @schema BucketSpecWebsiteRedirectAllRequestsTo#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'BucketSpecWebsiteRedirectAllRequestsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsiteRedirectAllRequestsTo(obj: BucketSpecWebsiteRedirectAllRequestsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostName': obj.hostName,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the redirect behavior and when a redirect is applied. For more information about routing rules, see Configuring advanced conditional redirects (https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html#advanced-conditional-redirects) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecWebsiteRoutingRules
 */
export interface BucketSpecWebsiteRoutingRules {
  /**
   * A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
   *
   * @schema BucketSpecWebsiteRoutingRules#condition
   */
  readonly condition?: BucketSpecWebsiteRoutingRulesCondition;

  /**
   * Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
   *
   * @schema BucketSpecWebsiteRoutingRules#redirect
   */
  readonly redirect?: BucketSpecWebsiteRoutingRulesRedirect;

}

/**
 * Converts an object of type 'BucketSpecWebsiteRoutingRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsiteRoutingRules(obj: BucketSpecWebsiteRoutingRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_BucketSpecWebsiteRoutingRulesCondition(obj.condition),
    'redirect': toJson_BucketSpecWebsiteRoutingRulesRedirect(obj.redirect),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates in any combination, and an object must match all of the predicates for the filter to apply.
 *
 * @schema BucketSpecAnalyticsFilterAnd
 */
export interface BucketSpecAnalyticsFilterAnd {
  /**
   * @schema BucketSpecAnalyticsFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecAnalyticsFilterAnd#tags
   */
  readonly tags?: BucketSpecAnalyticsFilterAndTags[];

}

/**
 * Converts an object of type 'BucketSpecAnalyticsFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsFilterAnd(obj: BucketSpecAnalyticsFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': obj.tags?.map(y => toJson_BucketSpecAnalyticsFilterAndTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecAnalyticsFilterTag
 */
export interface BucketSpecAnalyticsFilterTag {
  /**
   * @schema BucketSpecAnalyticsFilterTag#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecAnalyticsFilterTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsFilterTag(obj: BucketSpecAnalyticsFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for data related to the storage class analysis for an Amazon S3 bucket for export.
 *
 * @schema BucketSpecAnalyticsStorageClassAnalysisDataExport
 */
export interface BucketSpecAnalyticsStorageClassAnalysisDataExport {
  /**
   * Where to publish the analytics results.
   *
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExport#destination
   */
  readonly destination?: BucketSpecAnalyticsStorageClassAnalysisDataExportDestination;

  /**
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExport#outputSchemaVersion
   */
  readonly outputSchemaVersion?: string;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsStorageClassAnalysisDataExport' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsStorageClassAnalysisDataExport(obj: BucketSpecAnalyticsStorageClassAnalysisDataExport | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_BucketSpecAnalyticsStorageClassAnalysisDataExportDestination(obj.destination),
    'outputSchemaVersion': obj.outputSchemaVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. For more information, see PUT Bucket encryption (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the Amazon S3 API Reference.
 *
 * @schema BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault
 */
export interface BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault {
  /**
   * @schema BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault#kmsMasterKeyID
   */
  readonly kmsMasterKeyId?: string;

  /**
   * @schema BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault#sseAlgorithm
   */
  readonly sseAlgorithm?: string;

}

/**
 * Converts an object of type 'BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault(obj: BucketSpecEncryptionRulesApplyServerSideEncryptionByDefault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsMasterKeyID': obj.kmsMasterKeyId,
    'sseAlgorithm': obj.sseAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for specifying S3 Intelligent-Tiering filters. The filters determine the subset of objects to which the rule applies.
 *
 * @schema BucketSpecIntelligentTieringFilterAnd
 */
export interface BucketSpecIntelligentTieringFilterAnd {
  /**
   * @schema BucketSpecIntelligentTieringFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecIntelligentTieringFilterAnd#tags
   */
  readonly tags?: BucketSpecIntelligentTieringFilterAndTags[];

}

/**
 * Converts an object of type 'BucketSpecIntelligentTieringFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecIntelligentTieringFilterAnd(obj: BucketSpecIntelligentTieringFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': obj.tags?.map(y => toJson_BucketSpecIntelligentTieringFilterAndTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecIntelligentTieringFilterTag
 */
export interface BucketSpecIntelligentTieringFilterTag {
  /**
   * @schema BucketSpecIntelligentTieringFilterTag#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecIntelligentTieringFilterTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecIntelligentTieringFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecIntelligentTieringFilterTag(obj: BucketSpecIntelligentTieringFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the bucket name, file format, bucket owner (optional), and prefix (optional) where inventory results are published.
 *
 * @schema BucketSpecInventoryDestinationS3BucketDestination
 */
export interface BucketSpecInventoryDestinationS3BucketDestination {
  /**
   * @schema BucketSpecInventoryDestinationS3BucketDestination#accountID
   */
  readonly accountId?: string;

  /**
   * @schema BucketSpecInventoryDestinationS3BucketDestination#bucket
   */
  readonly bucket?: string;

  /**
   * Contains the type of server-side encryption used to encrypt the inventory results.
   *
   * @schema BucketSpecInventoryDestinationS3BucketDestination#encryption
   */
  readonly encryption?: BucketSpecInventoryDestinationS3BucketDestinationEncryption;

  /**
   * @schema BucketSpecInventoryDestinationS3BucketDestination#format
   */
  readonly format?: string;

  /**
   * @schema BucketSpecInventoryDestinationS3BucketDestination#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'BucketSpecInventoryDestinationS3BucketDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventoryDestinationS3BucketDestination(obj: BucketSpecInventoryDestinationS3BucketDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountID': obj.accountId,
    'bucket': obj.bucket,
    'encryption': toJson_BucketSpecInventoryDestinationS3BucketDestinationEncryption(obj.encryption),
    'format': obj.format,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecLifecycleRulesAbortIncompleteMultipartUpload
 */
export interface BucketSpecLifecycleRulesAbortIncompleteMultipartUpload {
  /**
   * @schema BucketSpecLifecycleRulesAbortIncompleteMultipartUpload#daysAfterInitiation
   */
  readonly daysAfterInitiation?: number;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesAbortIncompleteMultipartUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesAbortIncompleteMultipartUpload(obj: BucketSpecLifecycleRulesAbortIncompleteMultipartUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daysAfterInitiation': obj.daysAfterInitiation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the expiration for the lifecycle of the object.
 *
 * @schema BucketSpecLifecycleRulesExpiration
 */
export interface BucketSpecLifecycleRulesExpiration {
  /**
   * @schema BucketSpecLifecycleRulesExpiration#date
   */
  readonly date?: Date;

  /**
   * @schema BucketSpecLifecycleRulesExpiration#days
   */
  readonly days?: number;

  /**
   * @schema BucketSpecLifecycleRulesExpiration#expiredObjectDeleteMarker
   */
  readonly expiredObjectDeleteMarker?: boolean;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesExpiration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesExpiration(obj: BucketSpecLifecycleRulesExpiration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date?.toISOString(),
    'days': obj.days,
    'expiredObjectDeleteMarker': obj.expiredObjectDeleteMarker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Filter is used to identify objects that a Lifecycle Rule applies to. A Filter must have exactly one of Prefix, Tag, or And specified.
 *
 * @schema BucketSpecLifecycleRulesFilter
 */
export interface BucketSpecLifecycleRulesFilter {
  /**
   * This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator.
   *
   * @schema BucketSpecLifecycleRulesFilter#and
   */
  readonly and?: BucketSpecLifecycleRulesFilterAnd;

  /**
   * @schema BucketSpecLifecycleRulesFilter#prefix
   */
  readonly prefix?: string;

  /**
   * A container of a key value name pair.
   *
   * @schema BucketSpecLifecycleRulesFilter#tag
   */
  readonly tag?: BucketSpecLifecycleRulesFilterTag;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesFilter(obj: BucketSpecLifecycleRulesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': toJson_BucketSpecLifecycleRulesFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecLifecycleRulesFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies when noncurrent object versions expire. Upon expiration, Amazon S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that Amazon S3 delete noncurrent object versions at a specific period in the object's lifetime.
 *
 * @schema BucketSpecLifecycleRulesNoncurrentVersionExpiration
 */
export interface BucketSpecLifecycleRulesNoncurrentVersionExpiration {
  /**
   * @schema BucketSpecLifecycleRulesNoncurrentVersionExpiration#noncurrentDays
   */
  readonly noncurrentDays?: number;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesNoncurrentVersionExpiration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesNoncurrentVersionExpiration(obj: BucketSpecLifecycleRulesNoncurrentVersionExpiration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'noncurrentDays': obj.noncurrentDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
 *
 * @schema BucketSpecLifecycleRulesNoncurrentVersionTransitions
 */
export interface BucketSpecLifecycleRulesNoncurrentVersionTransitions {
  /**
   * @schema BucketSpecLifecycleRulesNoncurrentVersionTransitions#noncurrentDays
   */
  readonly noncurrentDays?: number;

  /**
   * @schema BucketSpecLifecycleRulesNoncurrentVersionTransitions#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesNoncurrentVersionTransitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesNoncurrentVersionTransitions(obj: BucketSpecLifecycleRulesNoncurrentVersionTransitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'noncurrentDays': obj.noncurrentDays,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies when an object transitions to a specified storage class. For more information about Amazon S3 lifecycle configuration rules, see Transitioning Objects Using Amazon S3 Lifecycle (https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecLifecycleRulesTransitions
 */
export interface BucketSpecLifecycleRulesTransitions {
  /**
   * @schema BucketSpecLifecycleRulesTransitions#date
   */
  readonly date?: Date;

  /**
   * @schema BucketSpecLifecycleRulesTransitions#days
   */
  readonly days?: number;

  /**
   * @schema BucketSpecLifecycleRulesTransitions#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesTransitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesTransitions(obj: BucketSpecLifecycleRulesTransitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date?.toISOString(),
    'days': obj.days,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for granting information.
 *
 * @schema BucketSpecLoggingLoggingEnabledTargetGrants
 */
export interface BucketSpecLoggingLoggingEnabledTargetGrants {
  /**
   * Container for the person being granted permissions.
   *
   * @schema BucketSpecLoggingLoggingEnabledTargetGrants#grantee
   */
  readonly grantee?: BucketSpecLoggingLoggingEnabledTargetGrantsGrantee;

  /**
   * @schema BucketSpecLoggingLoggingEnabledTargetGrants#permission
   */
  readonly permission?: string;

}

/**
 * Converts an object of type 'BucketSpecLoggingLoggingEnabledTargetGrants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLoggingLoggingEnabledTargetGrants(obj: BucketSpecLoggingLoggingEnabledTargetGrants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grantee': toJson_BucketSpecLoggingLoggingEnabledTargetGrantsGrantee(obj.grantee),
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply.
 *
 * @schema BucketSpecMetricsFilterAnd
 */
export interface BucketSpecMetricsFilterAnd {
  /**
   * @schema BucketSpecMetricsFilterAnd#accessPointARN
   */
  readonly accessPointArn?: string;

  /**
   * @schema BucketSpecMetricsFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecMetricsFilterAnd#tags
   */
  readonly tags?: BucketSpecMetricsFilterAndTags[];

}

/**
 * Converts an object of type 'BucketSpecMetricsFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecMetricsFilterAnd(obj: BucketSpecMetricsFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPointARN': obj.accessPointArn,
    'prefix': obj.prefix,
    'tags': obj.tags?.map(y => toJson_BucketSpecMetricsFilterAndTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecMetricsFilterTag
 */
export interface BucketSpecMetricsFilterTag {
  /**
   * @schema BucketSpecMetricsFilterTag#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecMetricsFilterTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecMetricsFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecMetricsFilterTag(obj: BucketSpecMetricsFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilter
 */
export interface BucketSpecNotificationLambdaFunctionConfigurationsFilter {
  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilter#key
   */
  readonly key?: BucketSpecNotificationLambdaFunctionConfigurationsFilterKey;

}

/**
 * Converts an object of type 'BucketSpecNotificationLambdaFunctionConfigurationsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationLambdaFunctionConfigurationsFilter(obj: BucketSpecNotificationLambdaFunctionConfigurationsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': toJson_BucketSpecNotificationLambdaFunctionConfigurationsFilterKey(obj.key),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecNotificationQueueConfigurationsFilter
 */
export interface BucketSpecNotificationQueueConfigurationsFilter {
  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * @schema BucketSpecNotificationQueueConfigurationsFilter#key
   */
  readonly key?: BucketSpecNotificationQueueConfigurationsFilterKey;

}

/**
 * Converts an object of type 'BucketSpecNotificationQueueConfigurationsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationQueueConfigurationsFilter(obj: BucketSpecNotificationQueueConfigurationsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': toJson_BucketSpecNotificationQueueConfigurationsFilterKey(obj.key),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies object key name filtering rules. For information about key name filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecNotificationTopicConfigurationsFilter
 */
export interface BucketSpecNotificationTopicConfigurationsFilter {
  /**
   * A container for object key name prefix and suffix filtering rules.
   *
   * @schema BucketSpecNotificationTopicConfigurationsFilter#key
   */
  readonly key?: BucketSpecNotificationTopicConfigurationsFilterKey;

}

/**
 * Converts an object of type 'BucketSpecNotificationTopicConfigurationsFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationTopicConfigurationsFilter(obj: BucketSpecNotificationTopicConfigurationsFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': toJson_BucketSpecNotificationTopicConfigurationsFilterKey(obj.key),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies whether Amazon S3 replicates delete markers. If you specify a Filter in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication Status must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).
 * For more information about delete marker replication, see Basic Rule Configuration (https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html).
 * If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see Backward Compatibility (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
 *
 * @schema BucketSpecReplicationRulesDeleteMarkerReplication
 */
export interface BucketSpecReplicationRulesDeleteMarkerReplication {
  /**
   * @schema BucketSpecReplicationRulesDeleteMarkerReplication#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDeleteMarkerReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDeleteMarkerReplication(obj: BucketSpecReplicationRulesDeleteMarkerReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
 *
 * @schema BucketSpecReplicationRulesDestination
 */
export interface BucketSpecReplicationRulesDestination {
  /**
   * A container for information about access control for replicas.
   *
   * @schema BucketSpecReplicationRulesDestination#accessControlTranslation
   */
  readonly accessControlTranslation?: BucketSpecReplicationRulesDestinationAccessControlTranslation;

  /**
   * @schema BucketSpecReplicationRulesDestination#account
   */
  readonly account?: string;

  /**
   * @schema BucketSpecReplicationRulesDestination#bucket
   */
  readonly bucket?: string;

  /**
   * Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
   *
   * @schema BucketSpecReplicationRulesDestination#encryptionConfiguration
   */
  readonly encryptionConfiguration?: BucketSpecReplicationRulesDestinationEncryptionConfiguration;

  /**
   * A container specifying replication metrics-related settings enabling replication metrics and events.
   *
   * @schema BucketSpecReplicationRulesDestination#metrics
   */
  readonly metrics?: BucketSpecReplicationRulesDestinationMetrics;

  /**
   * A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block.
   *
   * @schema BucketSpecReplicationRulesDestination#replicationTime
   */
  readonly replicationTime?: BucketSpecReplicationRulesDestinationReplicationTime;

  /**
   * @schema BucketSpecReplicationRulesDestination#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestination(obj: BucketSpecReplicationRulesDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlTranslation': toJson_BucketSpecReplicationRulesDestinationAccessControlTranslation(obj.accessControlTranslation),
    'account': obj.account,
    'bucket': obj.bucket,
    'encryptionConfiguration': toJson_BucketSpecReplicationRulesDestinationEncryptionConfiguration(obj.encryptionConfiguration),
    'metrics': toJson_BucketSpecReplicationRulesDestinationMetrics(obj.metrics),
    'replicationTime': toJson_BucketSpecReplicationRulesDestinationReplicationTime(obj.replicationTime),
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional configuration to replicate existing source bucket objects. For more information, see Replicating Existing Objects (https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-what-is-isnot-replicated.html#existing-object-replication) in the Amazon S3 User Guide.
 *
 * @schema BucketSpecReplicationRulesExistingObjectReplication
 */
export interface BucketSpecReplicationRulesExistingObjectReplication {
  /**
   * @schema BucketSpecReplicationRulesExistingObjectReplication#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesExistingObjectReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesExistingObjectReplication(obj: BucketSpecReplicationRulesExistingObjectReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A filter that identifies the subset of objects to which the replication rule applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
 *
 * @schema BucketSpecReplicationRulesFilter
 */
export interface BucketSpecReplicationRulesFilter {
  /**
   * A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter.
   * For example:
   * * If you specify both a Prefix and a Tag filter, wrap these filters in    an And tag.
   * * If you specify a filter based on multiple tags, wrap the Tag elements    in an And tag.
   *
   * @schema BucketSpecReplicationRulesFilter#and
   */
  readonly and?: BucketSpecReplicationRulesFilterAnd;

  /**
   * @schema BucketSpecReplicationRulesFilter#prefix
   */
  readonly prefix?: string;

  /**
   * A container of a key value name pair.
   *
   * @schema BucketSpecReplicationRulesFilter#tag
   */
  readonly tag?: BucketSpecReplicationRulesFilterTag;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesFilter(obj: BucketSpecReplicationRulesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': toJson_BucketSpecReplicationRulesFilterAnd(obj.and),
    'prefix': obj.prefix,
    'tag': toJson_BucketSpecReplicationRulesFilterTag(obj.tag),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. Currently, Amazon S3 supports only the filter that you can specify for objects created with server-side encryption using a customer managed key stored in Amazon Web Services Key Management Service (SSE-KMS).
 *
 * @schema BucketSpecReplicationRulesSourceSelectionCriteria
 */
export interface BucketSpecReplicationRulesSourceSelectionCriteria {
  /**
   * A filter that you can specify for selection for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when Filter is specified), you can specify this element and set the status to Enabled to replicate modifications on replicas.
   * If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, this element is not allowed.
   *
   * @schema BucketSpecReplicationRulesSourceSelectionCriteria#replicaModifications
   */
  readonly replicaModifications?: BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications;

  /**
   * A container for filter information for the selection of S3 objects encrypted with Amazon Web Services KMS.
   *
   * @schema BucketSpecReplicationRulesSourceSelectionCriteria#sseKMSEncryptedObjects
   */
  readonly sseKmsEncryptedObjects?: BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesSourceSelectionCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesSourceSelectionCriteria(obj: BucketSpecReplicationRulesSourceSelectionCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaModifications': toJson_BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications(obj.replicaModifications),
    'sseKMSEncryptedObjects': toJson_BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects(obj.sseKmsEncryptedObjects),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
 *
 * @schema BucketSpecWebsiteRoutingRulesCondition
 */
export interface BucketSpecWebsiteRoutingRulesCondition {
  /**
   * @schema BucketSpecWebsiteRoutingRulesCondition#httpErrorCodeReturnedEquals
   */
  readonly httpErrorCodeReturnedEquals?: string;

  /**
   * @schema BucketSpecWebsiteRoutingRulesCondition#keyPrefixEquals
   */
  readonly keyPrefixEquals?: string;

}

/**
 * Converts an object of type 'BucketSpecWebsiteRoutingRulesCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsiteRoutingRulesCondition(obj: BucketSpecWebsiteRoutingRulesCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpErrorCodeReturnedEquals': obj.httpErrorCodeReturnedEquals,
    'keyPrefixEquals': obj.keyPrefixEquals,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
 *
 * @schema BucketSpecWebsiteRoutingRulesRedirect
 */
export interface BucketSpecWebsiteRoutingRulesRedirect {
  /**
   * @schema BucketSpecWebsiteRoutingRulesRedirect#hostName
   */
  readonly hostName?: string;

  /**
   * @schema BucketSpecWebsiteRoutingRulesRedirect#httpRedirectCode
   */
  readonly httpRedirectCode?: string;

  /**
   * @schema BucketSpecWebsiteRoutingRulesRedirect#protocol
   */
  readonly protocol?: string;

  /**
   * @schema BucketSpecWebsiteRoutingRulesRedirect#replaceKeyPrefixWith
   */
  readonly replaceKeyPrefixWith?: string;

  /**
   * @schema BucketSpecWebsiteRoutingRulesRedirect#replaceKeyWith
   */
  readonly replaceKeyWith?: string;

}

/**
 * Converts an object of type 'BucketSpecWebsiteRoutingRulesRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWebsiteRoutingRulesRedirect(obj: BucketSpecWebsiteRoutingRulesRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostName': obj.hostName,
    'httpRedirectCode': obj.httpRedirectCode,
    'protocol': obj.protocol,
    'replaceKeyPrefixWith': obj.replaceKeyPrefixWith,
    'replaceKeyWith': obj.replaceKeyWith,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecAnalyticsFilterAndTags
 */
export interface BucketSpecAnalyticsFilterAndTags {
  /**
   * @schema BucketSpecAnalyticsFilterAndTags#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecAnalyticsFilterAndTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsFilterAndTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsFilterAndTags(obj: BucketSpecAnalyticsFilterAndTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Where to publish the analytics results.
 *
 * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestination
 */
export interface BucketSpecAnalyticsStorageClassAnalysisDataExportDestination {
  /**
   * Contains information about where to publish the analytics results.
   *
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestination#s3BucketDestination
   */
  readonly s3BucketDestination?: BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsStorageClassAnalysisDataExportDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsStorageClassAnalysisDataExportDestination(obj: BucketSpecAnalyticsStorageClassAnalysisDataExportDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3BucketDestination': toJson_BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination(obj.s3BucketDestination),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecIntelligentTieringFilterAndTags
 */
export interface BucketSpecIntelligentTieringFilterAndTags {
  /**
   * @schema BucketSpecIntelligentTieringFilterAndTags#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecIntelligentTieringFilterAndTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecIntelligentTieringFilterAndTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecIntelligentTieringFilterAndTags(obj: BucketSpecIntelligentTieringFilterAndTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the type of server-side encryption used to encrypt the inventory results.
 *
 * @schema BucketSpecInventoryDestinationS3BucketDestinationEncryption
 */
export interface BucketSpecInventoryDestinationS3BucketDestinationEncryption {
  /**
   * Specifies the use of SSE-KMS to encrypt delivered inventory reports.
   *
   * @schema BucketSpecInventoryDestinationS3BucketDestinationEncryption#sseKMS
   */
  readonly sseKms?: BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms;

}

/**
 * Converts an object of type 'BucketSpecInventoryDestinationS3BucketDestinationEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventoryDestinationS3BucketDestinationEncryption(obj: BucketSpecInventoryDestinationS3BucketDestinationEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sseKMS': toJson_BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms(obj.sseKms),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This is used in a Lifecycle Rule Filter to apply a logical AND to two or more predicates. The Lifecycle Rule will apply to any object matching all of the predicates configured inside the And operator.
 *
 * @schema BucketSpecLifecycleRulesFilterAnd
 */
export interface BucketSpecLifecycleRulesFilterAnd {
  /**
   * @schema BucketSpecLifecycleRulesFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecLifecycleRulesFilterAnd#tags
   */
  readonly tags?: BucketSpecLifecycleRulesFilterAndTags[];

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesFilterAnd(obj: BucketSpecLifecycleRulesFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': obj.tags?.map(y => toJson_BucketSpecLifecycleRulesFilterAndTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecLifecycleRulesFilterTag
 */
export interface BucketSpecLifecycleRulesFilterTag {
  /**
   * @schema BucketSpecLifecycleRulesFilterTag#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecLifecycleRulesFilterTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesFilterTag(obj: BucketSpecLifecycleRulesFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the person being granted permissions.
 *
 * @schema BucketSpecLoggingLoggingEnabledTargetGrantsGrantee
 */
export interface BucketSpecLoggingLoggingEnabledTargetGrantsGrantee {
  /**
   * @schema BucketSpecLoggingLoggingEnabledTargetGrantsGrantee#displayName
   */
  readonly displayName?: string;

  /**
   * @schema BucketSpecLoggingLoggingEnabledTargetGrantsGrantee#emailAddress
   */
  readonly emailAddress?: string;

  /**
   * @schema BucketSpecLoggingLoggingEnabledTargetGrantsGrantee#id
   */
  readonly id?: string;

  /**
   * @schema BucketSpecLoggingLoggingEnabledTargetGrantsGrantee#type_
   */
  readonly type?: string;

  /**
   * @schema BucketSpecLoggingLoggingEnabledTargetGrantsGrantee#uRI
   */
  readonly uRi?: string;

}

/**
 * Converts an object of type 'BucketSpecLoggingLoggingEnabledTargetGrantsGrantee' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLoggingLoggingEnabledTargetGrantsGrantee(obj: BucketSpecLoggingLoggingEnabledTargetGrantsGrantee | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'emailAddress': obj.emailAddress,
    'id': obj.id,
    'type_': obj.type,
    'uRI': obj.uRi,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecMetricsFilterAndTags
 */
export interface BucketSpecMetricsFilterAndTags {
  /**
   * @schema BucketSpecMetricsFilterAndTags#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecMetricsFilterAndTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecMetricsFilterAndTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecMetricsFilterAndTags(obj: BucketSpecMetricsFilterAndTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for object key name prefix and suffix filtering rules.
 *
 * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilterKey
 */
export interface BucketSpecNotificationLambdaFunctionConfigurationsFilterKey {
  /**
   * A list of containers for the key-value pair that defines the criteria for the filter rule.
   *
   * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilterKey#filterRules
   */
  readonly filterRules?: BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules[];

}

/**
 * Converts an object of type 'BucketSpecNotificationLambdaFunctionConfigurationsFilterKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationLambdaFunctionConfigurationsFilterKey(obj: BucketSpecNotificationLambdaFunctionConfigurationsFilterKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterRules': obj.filterRules?.map(y => toJson_BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for object key name prefix and suffix filtering rules.
 *
 * @schema BucketSpecNotificationQueueConfigurationsFilterKey
 */
export interface BucketSpecNotificationQueueConfigurationsFilterKey {
  /**
   * A list of containers for the key-value pair that defines the criteria for the filter rule.
   *
   * @schema BucketSpecNotificationQueueConfigurationsFilterKey#filterRules
   */
  readonly filterRules?: BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules[];

}

/**
 * Converts an object of type 'BucketSpecNotificationQueueConfigurationsFilterKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationQueueConfigurationsFilterKey(obj: BucketSpecNotificationQueueConfigurationsFilterKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterRules': obj.filterRules?.map(y => toJson_BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for object key name prefix and suffix filtering rules.
 *
 * @schema BucketSpecNotificationTopicConfigurationsFilterKey
 */
export interface BucketSpecNotificationTopicConfigurationsFilterKey {
  /**
   * A list of containers for the key-value pair that defines the criteria for the filter rule.
   *
   * @schema BucketSpecNotificationTopicConfigurationsFilterKey#filterRules
   */
  readonly filterRules?: BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules[];

}

/**
 * Converts an object of type 'BucketSpecNotificationTopicConfigurationsFilterKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationTopicConfigurationsFilterKey(obj: BucketSpecNotificationTopicConfigurationsFilterKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterRules': obj.filterRules?.map(y => toJson_BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for information about access control for replicas.
 *
 * @schema BucketSpecReplicationRulesDestinationAccessControlTranslation
 */
export interface BucketSpecReplicationRulesDestinationAccessControlTranslation {
  /**
   * @schema BucketSpecReplicationRulesDestinationAccessControlTranslation#owner
   */
  readonly owner?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestinationAccessControlTranslation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestinationAccessControlTranslation(obj: BucketSpecReplicationRulesDestinationAccessControlTranslation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'owner': obj.owner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
 *
 * @schema BucketSpecReplicationRulesDestinationEncryptionConfiguration
 */
export interface BucketSpecReplicationRulesDestinationEncryptionConfiguration {
  /**
   * @schema BucketSpecReplicationRulesDestinationEncryptionConfiguration#replicaKMSKeyID
   */
  readonly replicaKmsKeyId?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestinationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestinationEncryptionConfiguration(obj: BucketSpecReplicationRulesDestinationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaKMSKeyID': obj.replicaKmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying replication metrics-related settings enabling replication metrics and events.
 *
 * @schema BucketSpecReplicationRulesDestinationMetrics
 */
export interface BucketSpecReplicationRulesDestinationMetrics {
  /**
   * A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold.
   *
   * @schema BucketSpecReplicationRulesDestinationMetrics#eventThreshold
   */
  readonly eventThreshold?: BucketSpecReplicationRulesDestinationMetricsEventThreshold;

  /**
   * @schema BucketSpecReplicationRulesDestinationMetrics#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestinationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestinationMetrics(obj: BucketSpecReplicationRulesDestinationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventThreshold': toJson_BucketSpecReplicationRulesDestinationMetricsEventThreshold(obj.eventThreshold),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block.
 *
 * @schema BucketSpecReplicationRulesDestinationReplicationTime
 */
export interface BucketSpecReplicationRulesDestinationReplicationTime {
  /**
   * @schema BucketSpecReplicationRulesDestinationReplicationTime#status
   */
  readonly status?: string;

  /**
   * A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold.
   *
   * @schema BucketSpecReplicationRulesDestinationReplicationTime#time
   */
  readonly time?: BucketSpecReplicationRulesDestinationReplicationTimeTime;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestinationReplicationTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestinationReplicationTime(obj: BucketSpecReplicationRulesDestinationReplicationTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'time': toJson_BucketSpecReplicationRulesDestinationReplicationTimeTime(obj.time),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter.
 * For example:
 * * If you specify both a Prefix and a Tag filter, wrap these filters in    an And tag.
 * * If you specify a filter based on multiple tags, wrap the Tag elements    in an And tag.
 *
 * @schema BucketSpecReplicationRulesFilterAnd
 */
export interface BucketSpecReplicationRulesFilterAnd {
  /**
   * @schema BucketSpecReplicationRulesFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * @schema BucketSpecReplicationRulesFilterAnd#tags
   */
  readonly tags?: BucketSpecReplicationRulesFilterAndTags[];

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesFilterAnd(obj: BucketSpecReplicationRulesFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': obj.tags?.map(y => toJson_BucketSpecReplicationRulesFilterAndTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecReplicationRulesFilterTag
 */
export interface BucketSpecReplicationRulesFilterTag {
  /**
   * @schema BucketSpecReplicationRulesFilterTag#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecReplicationRulesFilterTag#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesFilterTag(obj: BucketSpecReplicationRulesFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A filter that you can specify for selection for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when Filter is specified), you can specify this element and set the status to Enabled to replicate modifications on replicas.
 * If you don't specify the Filter element, Amazon S3 assumes that the replication configuration is the earlier version, V1. In the earlier version, this element is not allowed.
 *
 * @schema BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications
 */
export interface BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications {
  /**
   * @schema BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications(obj: BucketSpecReplicationRulesSourceSelectionCriteriaReplicaModifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container for filter information for the selection of S3 objects encrypted with Amazon Web Services KMS.
 *
 * @schema BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects
 */
export interface BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects {
  /**
   * @schema BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects(obj: BucketSpecReplicationRulesSourceSelectionCriteriaSseKmsEncryptedObjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains information about where to publish the analytics results.
 *
 * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination
 */
export interface BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination {
  /**
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination#bucket
   */
  readonly bucket?: string;

  /**
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination#bucketAccountID
   */
  readonly bucketAccountId?: string;

  /**
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination#format
   */
  readonly format?: string;

  /**
   * @schema BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination(obj: BucketSpecAnalyticsStorageClassAnalysisDataExportDestinationS3BucketDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketAccountID': obj.bucketAccountId,
    'format': obj.format,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the use of SSE-KMS to encrypt delivered inventory reports.
 *
 * @schema BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms
 */
export interface BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms {
  /**
   * @schema BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms#keyID
   */
  readonly keyId?: string;

}

/**
 * Converts an object of type 'BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms(obj: BucketSpecInventoryDestinationS3BucketDestinationEncryptionSseKms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyID': obj.keyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecLifecycleRulesFilterAndTags
 */
export interface BucketSpecLifecycleRulesFilterAndTags {
  /**
   * @schema BucketSpecLifecycleRulesFilterAndTags#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecLifecycleRulesFilterAndTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecLifecycleRulesFilterAndTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecLifecycleRulesFilterAndTags(obj: BucketSpecLifecycleRulesFilterAndTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
 *
 * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules
 */
export interface BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules {
  /**
   * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules#name
   */
  readonly name?: string;

  /**
   * @schema BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules(obj: BucketSpecNotificationLambdaFunctionConfigurationsFilterKeyFilterRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
 *
 * @schema BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules
 */
export interface BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules {
  /**
   * @schema BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules#name
   */
  readonly name?: string;

  /**
   * @schema BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules(obj: BucketSpecNotificationQueueConfigurationsFilterKeyFilterRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
 *
 * @schema BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules
 */
export interface BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules {
  /**
   * @schema BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules#name
   */
  readonly name?: string;

  /**
   * @schema BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules(obj: BucketSpecNotificationTopicConfigurationsFilterKeyFilterRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold.
 *
 * @schema BucketSpecReplicationRulesDestinationMetricsEventThreshold
 */
export interface BucketSpecReplicationRulesDestinationMetricsEventThreshold {
  /**
   * @schema BucketSpecReplicationRulesDestinationMetricsEventThreshold#minutes
   */
  readonly minutes?: number;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestinationMetricsEventThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestinationMetricsEventThreshold(obj: BucketSpecReplicationRulesDestinationMetricsEventThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics EventThreshold.
 *
 * @schema BucketSpecReplicationRulesDestinationReplicationTimeTime
 */
export interface BucketSpecReplicationRulesDestinationReplicationTimeTime {
  /**
   * @schema BucketSpecReplicationRulesDestinationReplicationTimeTime#minutes
   */
  readonly minutes?: number;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesDestinationReplicationTimeTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesDestinationReplicationTimeTime(obj: BucketSpecReplicationRulesDestinationReplicationTimeTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A container of a key value name pair.
 *
 * @schema BucketSpecReplicationRulesFilterAndTags
 */
export interface BucketSpecReplicationRulesFilterAndTags {
  /**
   * @schema BucketSpecReplicationRulesFilterAndTags#key
   */
  readonly key?: string;

  /**
   * @schema BucketSpecReplicationRulesFilterAndTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'BucketSpecReplicationRulesFilterAndTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecReplicationRulesFilterAndTags(obj: BucketSpecReplicationRulesFilterAndTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

